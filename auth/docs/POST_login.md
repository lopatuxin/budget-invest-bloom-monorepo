# Backend Specification - POST login

## Общее описание

Endpoint для аутентификации пользователей в системе ведения личных финансов. Позволяет зарегистрированным пользователям войти в систему используя email и пароль. После успешной аутентификации возвращает пару JWT токенов (access и refresh) для авторизации последующих запросов к защищенным ресурсам системы.

**Важно**: Rate limiting обрабатывается на уровне API Gateway согласно архитектуре микросервисов проекта.

## Endpoint

```
POST /api/login
```

## Структура запроса

Запрос использует **стандартный формат API** (подробнее в [standartRequestAndResponse.md](standartRequestAndResponse.md)):

| Поле   | Тип    | Обязательное | Описание                                                     |
|--------|--------|--------------|--------------------------------------------------------------|
| `user` | object | Нет          | Контекст пользователя (null для публичного endpoint)         |
| `data` | object | Да           | Данные для аутентификации пользователя                       |

### Блок `data` - параметры аутентификации

| Параметр   | Тип    | Обязательный | Описание                                    |
|------------|--------|--------------|---------------------------------------------|
| `email`    | string | Да           | Email адрес зарегистрированного пользователя |
| `password` | string | Да           | Пароль пользователя                         |

### Пример запроса

```json
{
  "user": null,
  "data": {
    "email": "user@example.com",
    "password": "mypassword123"
  }
}
```

## Логика обработки

1. **Валидация входных данных**:
    - Проверка наличия обязательных полей `email` и `password`
    - Нормализация email адреса (приведение к нижнему регистру, удаление пробелов)
    - Базовая валидация формата email адреса

2. **Поиск пользователя**:
    - Поиск пользователя в таблице `user` по email адресу
    - Если пользователь не найден, возвращается ошибка `401 Unauthorized`

3. **Проверка статуса аккаунта**:
    - Проверка, что аккаунт активен (`is_active = true`)
    - Если аккаунт заблокирован, возвращается ошибка `403 Forbidden`

4. **Верификация пароля**:
    - Сравнение введенного пароля с сохраненным хешем используя bcrypt
    - При неверном пароле увеличивается счетчик неудачных попыток
    - После 5 неудачных попыток аккаунт временно блокируется на 30 минут

5. **Генерация JWT токенов**:
    - Создание Access Token со сроком жизни 15 минут
    - Создание Refresh Token со сроком жизни 7 дней
    - Включение в payload токенов: `userId`, `email`, `roles`, `exp`, `iat`
    - Refresh Token передается клиенту через HTTP Cookie (HttpOnly, Secure)

6. **Обновление данных сессии**:
    - Сохранение информации о сессии в базе данных
    - Обновление поля `last_login_at` в таблице `user`
    - Сброс счетчика неудачных попыток входа

7. **Логирование и аудит**:
    - Запись успешного входа в журнал аудита
    - Сохранение IP адреса, User-Agent и временной метки

## Структура ответа

Ответ использует **стандартный формат API** (подробнее в [standartRequestAndResponse.md](standartRequestAndResponse.md)):

| Поле        | Тип     | Описание                                                      |
|-------------|---------|---------------------------------------------------------------|
| `id`        | string  | Уникальный идентификатор запроса в формате UUID               |
| `status`    | number  | HTTP статус код ответа (200)                                  |
| `message`   | string  | Сообщение об успешной аутентификации                          |
| `timestamp` | string  | Временная метка формирования ответа в ISO 8601 UTC формате    |
| `body`      | object  | Объект с данными токена и пользователя                        |

### Блок `body` - данные аутентификации

| Поле           | Тип      | Описание                                     |
|----------------|----------|----------------------------------------------|
| `accessToken`  | string   | JWT токен для авторизации API запросов      |
| `tokenType`    | string   | Тип токена (всегда `"Bearer"`)              |
| `expiresIn`    | number   | Время жизни access токена в секундах        |
| `user`         | object   | Информация о пользователе                    |

### Структура объекта `user`

| Поле         | Тип      | Описание                                     |
|--------------|----------|----------------------------------------------|
| `userId`     | string   | Уникальный идентификатор пользователя        |
| `email`      | string   | Email адрес пользователя                     |
| `isActive`   | boolean  | Статус активности аккаунта                   |
| `isVerified` | boolean  | Статус подтверждения email                   |
| `roles`      | array    | Список ролей пользователя                    |
| `lastLoginAt`| string   | Время последнего входа в ISO 8601 формате   |

### HTTP Cookie

| Параметр      | Значение                                           |
|---------------|---------------------------------------------------|
| `Name`        | `refreshToken`                                    |
| `Value`       | JWT refresh token                                 |
| `HttpOnly`    | `true` (защита от XSS)                           |
| `Secure`      | `true` (только HTTPS)                            |
| `SameSite`    | `Strict` (защита от CSRF)                        |
| `Max-Age`     | 7 дней (604800 секунд)                           |

### Пример успешного ответа

**JSON Response:**
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "status": 200,
  "message": "Аутентификация прошла успешно",
  "timestamp": "2025-08-07T12:30:45.123Z",
  "body": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900,
    "user": {
      "userId": "456e7890-e89b-12d3-a456-426614174000",
      "email": "user@example.com",
      "isActive": true,
      "isVerified": true,
      "roles": ["USER"],
      "lastLoginAt": "2025-08-07T12:30:45.123Z"
    }
  }
}
```

**HTTP Headers (включая Cookie):**
```
Set-Cookie: refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; HttpOnly; Secure; SameSite=Strict; Max-Age=604800; Path=/
```

## Коды состояния

| Код | Сообщение             | Описание                                                         |
|-----|-----------------------|------------------------------------------------------------------|
| 200 | OK                    | Аутентификация прошла успешно                                    |
| 400 | Bad Request           | Некорректные данные запроса (отсутствуют обязательные поля)     |
| 401 | Unauthorized          | Неверные учетные данные (email или пароль)                      |
| 403 | Forbidden             | Аккаунт заблокирован или неактивен                              |
| 422 | Unprocessable Entity  | Ошибки валидации входных данных                                  |
| 429 | Too Many Requests     | Превышен лимит попыток входа (обрабатывается API Gateway)       |
| 500 | Internal Server Error | Внутренняя ошибка сервера при аутентификации                     |

### Примеры ошибок

**401 Unauthorized - неверные учетные данные:**
```json
{
  "error": "INVALID_CREDENTIALS",
  "message": "Неверный email или пароль",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**403 Forbidden - аккаунт заблокирован:**
```json
{
  "error": "ACCOUNT_LOCKED",
  "message": "Аккаунт временно заблокирован из-за множественных неудачных попыток входа",
  "lockedUntil": "2025-08-07T13:00:45.123Z"
}
```

**403 Forbidden - неактивный аккаунт:**
```json
{
  "error": "ACCOUNT_INACTIVE",
  "message": "Аккаунт деактивирован. Обратитесь в службу поддержки"
}
```

**429 Too Many Requests (обрабатывается API Gateway):**
```json
{
  "error": "RATE_LIMIT_EXCEEDED",
  "message": "Слишком много попыток входа. Попробуйте через несколько минут",
  "retryAfter": 300
}
```

**400 Bad Request - отсутствуют обязательные поля:**
```json
{
  "error": "MISSING_REQUIRED_FIELDS",
  "message": "Отсутствуют обязательные поля: email, password",
  "fields": ["email", "password"]
}
```

## Безопасность и ограничения

### Разделение ответственности
- **API Gateway**: отвечает за общий rate limiting (5 попыток/минуту с IP)
- **Auth Service**: отвечает за логику блокировки аккаунтов (5 неудачных попыток)

### Защита от атак
- **Account Lockout**: временная блокировка аккаунта после 5 неудачных попыток
- **Brute Force Protection**: автоматическая блокировка подозрительной активности
- **JWT Security**: подписанные токены с коротким временем жизни
- **Secure Password Comparison**: использование bcrypt для сравнения паролей
- **Input Validation**: строгая валидация всех входящих данных

### Аудит и логирование
- Логирование всех попыток входа (успешных и неудачных)
- Сохранение IP адреса, User-Agent и геолокации
- Мониторинг подозрительной активности
- Отслеживание множественных неудачных попыток
- Уведомления о входе с новых устройств или локаций

### Ограничения
- Максимум 5 активных сессий на одного пользователя
- Access токен действителен 15 минут
- Refresh токен действителен 7 дней
- Автоматический logout при бездействии более 24 часов
- Блокировка аккаунта на 30 минут после 5 неудачных попыток

## Интеграция с другими компонентами

### База данных
- Чтение данных из таблицы `user`
- Обновление поля `last_login_at`
- Увеличение счетчика неудачных попыток при ошибке
- Сохранение информации о блокировке аккаунта

### Кэширование (Redis)
- Сохранение информации о сессии с TTL
- Кэширование refresh токенов
- Блеклист для отозванных токенов

### API Gateway
- Обработка общего rate limiting по IP
- JWT валидация для последующих запросов
- Маршрутизация к Auth Service

### Зависимости
- **JWT Library**: для создания и подписи токенов
- **bcrypt**: для верификации паролей
- **Redis**: для управления сессиями
- **PostgreSQL**: для хранения пользовательских данных

### Связь с другими API
После успешной аутентификации пользователь может:
- Использовать access токен для доступа к защищенным ресурсам
- Обновить токены через `POST /api/auth/refresh`
- Выйти из системы через `POST /api/auth/logout`
- Управлять активными сессиями через `GET /api/auth/sessions`

## События и уведомления

### Kafka Events
При успешной аутентификации отправляются события:
- `user.logged_in`: информация о входе пользователя в систему
- `security.login_success`: данные для аудита безопасности

При неудачной аутентификации:
- `security.login_failed`: данные о неудачной попытке входа
- `security.account_locked`: уведомление о блокировке аккаунта

### Уведомления пользователя
- Email уведомление о входе с нового устройства
- SMS уведомление при подозрительной активности
- Push уведомление в мобильном приложении

## Тестирование

### Позитивные сценарии
- Успешная аутентификация с валидными учетными данными
- Проверка генерации JWT токенов
- Обновление времени последнего входа
- Создание сессии в Redis
- Отправка событий в Kafka

### Негативные сценарии
- Попытка входа с несуществующим email
- Попытка входа с неверным паролем
- Вход в заблокированный аккаунт
- Превышение rate limit (тест на уровне API Gateway)
- Попытка входа в неактивный аккаунт
- Обработка ошибок базы данных и Redis

### Безопасность
- Тестирование brute force атак
- Проверка account lockout функциональности
- Валидация JWT токенов
- Проверка защиты от SQL injection

### Нагрузочное тестирование
- Одновременная аутентификация множества пользователей
- Проверка производительности генерации JWT токенов
- Тестирование Redis под высокой нагрузкой
- Проверка стабильности при пиковых нагрузках