# Backend Specification - POST refresh

## Общее описание

Endpoint для обновления JWT токенов в системе ведения личных финансов. Позволяет пользователям получить новую пару токенов (access и refresh) используя действующий refresh token. Реализует безопасную стратегию Refresh Token Rotation для предотвращения атак с украденными токенами и обеспечения непрерывного доступа к защищенным ресурсам системы.

**Важно**: Endpoint использует принцип Refresh Token Rotation - каждое обновление выдает новый refresh token и инвалидирует предыдущий.

## Endpoint

```
POST /api/auth/refresh
```

## Структура запроса

**Важно**: Refresh token передается через HTTP Cookie, а не в теле запроса.

### HTTP Cookie (обязательно)

| Параметр       | Тип    | Описание                                         |
|----------------|--------|--------------------------------------------------|
| `refreshToken` | string | Действующий refresh token для обновления токенов |

### Пример запроса

**HTTP Headers (включая Cookie):**
```
Cookie: refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Body:** Пустое тело запроса или отсутствует

## Логика обработки

1. **Валидация входных данных**:
    - Проверка наличия обязательного поля `refreshToken`
    - Базовая валидация формата JWT токена
    - Проверка, что токен не является пустой строкой

2. **Верификация refresh token**:
    - Проверка подписи refresh token с использованием секретного ключа
    - Валидация срока действия токена (`exp` claim)
    - Извлечение `userId`, `sessionId` и `tokenVersion` из payload
    - Если токен недействителен, возвращается ошибка `401 Unauthorized`

4. **Валидация пользователя и сессии**:
    - Поиск пользователя в БД по `userId` из токена
    - Проверка активности аккаунта (`is_active = true`)
    - Проверка совпадения `tokenVersion` в токене и БД (защита от краж)
    - Валидация существования сессии в Redis cache

6. **Генерация новых токенов**:
    - Создание нового Access Token со сроком жизни 15 минут
    - Создание нового Refresh Token со сроком жизни 7 дней
    - Включение в payload: `userId`, `email`, `roles`, `sessionId`, `tokenVersion`
    - Обновление `tokenVersion` для нового refresh token

7. **Обновление сессионных данных**:
    - Сохранение информации о новой сессии в базе данных
    - Обновление поля `last_activity_at` в таблице `user`
    - Сохранение метаданных сессии (IP, User-Agent, timestamp)
    - Новый Refresh Token передается клиенту через HTTP Cookie (HttpOnly, Secure)

## Структура ответа

Ответ использует **стандартный формат API** (подробнее в [standartRequestAndResponse.md](standartRequestAndResponse.md)):

| Поле        | Тип     | Описание                                                      |
|-------------|---------|---------------------------------------------------------------|
| `id`        | string  | Уникальный идентификатор запроса в формате UUID               |
| `status`    | number  | HTTP статус код ответа (200)                                  |
| `message`   | string  | Сообщение об успешном обновлении токенов                      |
| `timestamp` | string  | Временная метка формирования ответа в ISO 8601 UTC формате    |
| `body`      | object  | Объект с новым access токеном                                 |

### Блок `body` - данные обновленных токенов

| Поле           | Тип      | Описание                                     |
|----------------|----------|----------------------------------------------|
| `accessToken`  | string   | Новый JWT токен для авторизации API запросов |
| `tokenType`    | string   | Тип токена (всегда `"Bearer"`)              |
| `expiresIn`    | number   | Время жизни access токена в секундах        |

### HTTP Cookie

| Параметр      | Значение                                           |
|---------------|---------------------------------------------------|
| `Name`        | `refreshToken`                                    |
| `Value`       | Новый JWT refresh token                           |
| `HttpOnly`    | `true` (защита от XSS)                           |
| `Secure`      | `true` (только HTTPS)                            |
| `SameSite`    | `Strict` (защита от CSRF)                        |
| `Max-Age`     | 7 дней (604800 секунд)                           |

### Пример успешного ответа

**JSON Response:**
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "status": 200,
  "message": "Токены успешно обновлены",
  "timestamp": "2025-08-07T12:30:45.123Z",
  "body": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900
  }
}
```

**HTTP Headers (включая Cookie):**
```
Set-Cookie: refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; HttpOnly; Secure; SameSite=Strict; Max-Age=604800; Path=/
```

## Коды состояния

| Код | Сообщение             | Описание                                                         |
|-----|-----------------------|------------------------------------------------------------------|
| 200 | OK                    | Токены успешно обновлены                                         |
| 400 | Bad Request           | Некорректные данные запроса (отсутствует refresh token)         |
| 401 | Unauthorized          | Недействительный или истекший refresh token                     |
| 403 | Forbidden             | Refresh token отозван, использован или аккаунт заблокирован     |
| 404 | Not Found             | Пользователь или сессия не найдены                              |
| 422 | Unprocessable Entity  | Ошибки валидации refresh token                                   |
| 429 | Too Many Requests     | Превышен лимит операций refresh (защита от злоупотреблений)     |
| 500 | Internal Server Error | Внутренняя ошибка сервера при обновлении токенов                |

### Примеры ошибок

**400 Bad Request - отсутствует refresh token:**
```json
{
  "error": "MISSING_REFRESH_TOKEN",
  "message": "Отсутствует обязательное поле refreshToken",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**401 Unauthorized - истекший токен:**
```json
{
  "error": "REFRESH_TOKEN_EXPIRED",
  "message": "Refresh token истек. Требуется повторная аутентификация",
  "expiredAt": "2025-08-01T12:30:45.123Z",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**401 Unauthorized - недействительная подпись:**
```json
{
  "error": "INVALID_REFRESH_TOKEN",
  "message": "Refresh token имеет недействительную подпись",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**403 Forbidden - токен уже использован:**
```json
{
  "error": "REFRESH_TOKEN_REUSED",
  "message": "Refresh token уже был использован. Возможна компрометация сессии",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**403 Forbidden - токен в blacklist:**
```json
{
  "error": "REFRESH_TOKEN_REVOKED",
  "message": "Refresh token был отозван",
  "revokedAt": "2025-08-06T10:15:30.456Z",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**403 Forbidden - неактивный аккаунт:**
```json
{
  "error": "ACCOUNT_INACTIVE",
  "message": "Аккаунт деактивирован. Обратитесь в службу поддержки",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**404 Not Found - сессия не найдена:**
```json
{
  "error": "SESSION_NOT_FOUND",
  "message": "Сессия не найдена или истекла",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**422 Unprocessable Entity - неверный формат:**
```json
{
  "error": "MALFORMED_REFRESH_TOKEN",
  "message": "Refresh token имеет неверный формат",
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

**429 Too Many Requests - превышен лимит:**
```json
{
  "error": "REFRESH_RATE_LIMIT_EXCEEDED",
  "message": "Слишком много операций обновления токенов. Попробуйте через несколько минут",
  "retryAfter": 300,
  "timestamp": "2025-08-07T12:30:45.123Z"
}
```

## Безопасность и ограничения

### Refresh Token Rotation
- **One-time Use**: каждый refresh token может быть использован только один раз
- **Automatic Invalidation**: старый refresh token немедленно добавляется в blacklist
- **Chain Invalidation**: при обнаружении повторного использования инвалидируются все токены сессии
- **Version Control**: использование `tokenVersion` для защиты от replay атак

### Защита от атак
- **Token Reuse Detection**: обнаружение и блокировка при повторном использовании токенов
- **Rate Limiting**: максимум 10 refresh операций в минуту на пользователя
- **IP Validation**: мониторинг подозрительных изменений IP адресов
- **Concurrent Session Control**: ограничение количества активных сессий

### Временные ограничения
- **Access Token TTL**: 15 минут (900 секунд)
- **Refresh Token TTL**: 7 дней (604800 секунд)
- **Grace Period**: 30 секунд для синхронизации между серверами
- **Blacklist TTL**: до истечения срока действия токена

### Аудит и мониторинг
- **Security Events**: логирование всех операций refresh
- **Anomaly Detection**: обнаружение подозрительных паттернов
- **Session Tracking**: отслеживание всех активных сессий пользователя
- **Geographic Monitoring**: анализ изменений геолокации

### Производительность
- **Redis Caching**: быстрая проверка blacklist и сессий
- **JWT Optimization**: минимальный payload для снижения размера токенов
- **Connection Pooling**: эффективное использование соединений с БД
- **Async Processing**: асинхронная обработка аудита и уведомлений

## Интеграция с другими компонентами

### База данных
- Чтение данных из таблицы `user` для валидации
- Обновление поля `last_activity_at`
- Проверка и обновление `token_version`
- Запись в таблицу `audit_log` для безопасности

### Кэширование (Redis)
- Проверка refresh token в blacklist
- Сохранение новых сессионных данных
- Кэширование информации о пользователе
- Управление rate limiting счетчиками

### API Gateway
- Валидация новых access токенов для последующих запросов
- Проверка blacklist при маршрутизации
- Автоматическое обновление кэша токенов

### Security Service
- Отправка событий о подозрительной активности
- Интеграция с системой fraud detection
- Мониторинг паттернов использования токенов

### Зависимости
- **JWT Library**: для создания, подписи и валидации токенов
- **Redis**: для blacklist, сессий и rate limiting
- **PostgreSQL**: для пользовательских данных и аудита
- **Crypto Library**: для безопасной генерации токенов

### Связь с другими API
После обновления токенов:
- Использование нового access токена для доступа к защищенным ресурсам
- Возможность завершения сессии через [POST /api/auth/logout](POST_logout.md)
- При истечении refresh токена - повторная аутентификация через [POST /api/login](POST_login.md)

## События и уведомления

### Kafka Events
При успешном обновлении токенов:
- `auth.tokens_refreshed`: информация об обновлении токенов
- `security.token_rotation`: данные для аудита безопасности
- `user.activity_updated`: обновление активности пользователя

При обнаружении подозрительной активности:
- `security.suspicious_refresh`: подозрительные паттерны refresh
- `security.token_reuse_detected`: обнаружение повторного использования токенов
- `security.session_compromised`: возможная компрометация сессии

### Уведомления пользователя
- Email уведомление при обнаружении подозрительной активности
- Push уведомление о возможной компрометации аккаунта
- SMS алерт при критических нарушениях безопасности

### Аналитика
- Метрики частоты обновления токенов
- Статистика времени жизни сессий
- Аналитика географического распределения refresh операций

## Edge Cases и особые сценарии

### Concurrent Refresh
- **Проблема**: одновременные refresh запросы с одним токеном
- **Решение**: использование Redis SETNX для атомарности операций
- **Результат**: только первый запрос успешен, остальные получают 403

### Token Version Mismatch
- **Проблема**: refresh token с устаревшей версией
- **Решение**: сравнение `tokenVersion` в токене и БД
- **Результат**: инвалидация всех токенов и требование повторной аутентификации

### Network Failures
- **Проблема**: сбой сети после инвалидации старого токена
- **Решение**: graceful rollback с восстановлением предыдущего состояния
- **Результат**: пользователь не теряет доступ к системе

### Clock Skew
- **Проблема**: рассинхронизация времени между серверами
- **Решение**: grace period в 30 секунд для JWT валидации
- **Результат**: избежание ложных срабатываний истечения токенов

## Тестирование

### Позитивные сценарии
- Успешное обновление токенов с валидным refresh token
- Проверка rotation старого токена в blacklist
- Обновление сессионных данных в Redis
- Валидация новых JWT токенов
- Отправка корректных событий в Kafka

### Негативные сценарии
- Попытка использования истекшего refresh token
- Повторное использование уже использованного токена
- Refresh с отозванным токеном из blacklist
- Попытка refresh для неактивного пользователя
- Обработка неверного формата refresh token

### Безопасность
- Тестирование token reuse detection
- Проверка rate limiting механизмов
- Валидация blacklist функциональности
- Тестирование защиты от replay атак
- Проверка version control логики

### Нагрузочное тестирование
- Множественные одновременные refresh операции
- Производительность Redis операций под нагрузкой
- Тестирование concurrent refresh scenarios
- Проверка стабильности при высокой частоте refresh

### Интеграционное тестирование
- Интеграция с API Gateway для валидации новых токенов
- Проверка отправки Kafka событий
- Тестирование обновления данных в PostgreSQL
- Интеграция с Security Service для fraud detection